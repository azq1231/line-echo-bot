改程式後，遠端需要重新啟動
sudo systemctl restart mywebsite
sudo systemctl status mywebsite

本地測試用的終端機啟動命令
venv\Scripts\activate

python main.py

新增vue環境，開新終端機
venv\Scripts\activate
cd frontend
npm run dev

若要停用虛擬環境，只需輸入 deactivate

appointments.db 檔案是一個 SQLite 資料庫檔案，
它包含了您系統中所有重要的資料，包括：

✅ 您的時段設定 (available_slots 資料表)
✅ 所有用戶資料 (users 資料表)
✅ 所有預約紀錄 (appointments 資料表)
✅ 休診日設定 (closed_days 資料表)
✅ 系統設定 (configs 資料表)

1.用戶回復時，可以在預約簿上點選確認
    請幫我設計一個功能，當使用者在 LINE 回覆訊息時，管理者可以在預約簿上看到並點擊確認。
2.在設定中，可以編輯預約簿的發送訊息功能中，要發送的預約提醒訊息
3.
4.
5.

其他問題

請幫我將專案結構模組化，拆分 `main.py`。
初始目標（最小風險）

在專案根目錄建立 app/ 資料夾，保留現有 main.py 但把它變成短小的啟動檔（只做 app init 與 run）。

在 app/ 下建立 __init__.py（create_app）來初始化 Flask、logger、db、藍圖（blueprints）。

把路由分到 app/routes/（例如 auth.py、admin.py、appointments.py），每個檔案只包含自己那組 route。

把工具函式放 app/utils/（logger、LINE API wrapper、helpers）。

把 scheduler 相關放 app/scheduler.py（或 app/scheduler/jobs.py），並只在 production 模式啟動 scheduler。

更新 main.py 只做 from app import create_app，然後 app.run(...)。

檔案與目錄建議（模板）
project-root/
├── main.py                # 啟動檔（非常小）
├── app/
│   ├── __init__.py        # create_app()，註冊藍圖、載入設定、初始化 logger/db
│   ├── routes/
│   │   ├── auth.py        # /login, /callback, /logout
│   │   ├── admin.py       # /admin/* 與 /api/admin/*
│   │   └── booking.py     # booking_page, booking APIs
│   ├── utils/
│   │   ├── logger.py      # logging 設定
│   │   ├── db.py          # 介於你現有 db wrapper（或只是 import 既有 db）
│   │   └── line_api.py    # get_line_profile, send_line_message 包裝
│   ├── scheduler/
│   │   └── jobs.py        # send_daily_reminders_job 等
│   └── templates/         # 若你把 jinja2 模板也放在這
└── static/

每個檔案應該放什麼（簡短說明）

app/__init__.py：建立 Flask app，讀設定、初始化 db、註冊藍圖 from .routes import auth, admin, booking; app.register_blueprint(...)，設定 app.permanent_session_lifetime、logging 等。

app/routes/auth.py：跟登入、callback、session 有關的 route。

app/routes/admin.py：包含 @admin_required 裝飾器路由（使用者管理、configs、API）。

app/routes/booking.py：顯示預約頁、booking API、history 等。

app/utils/logger.py：統一 logger 設定，export get_logger()。

app/scheduler/jobs.py：把 send_daily_reminders_job、send_weekly_reminders_job、send_custom_schedules_job 放這裡，並提供 init_scheduler(app) 供 create_app 在 production 時呼叫。

main.py：只做 app = create_app(); if __name__ == "__main__": app.run(...)。

漸進搬移步驟（具體）

建 app/__init__.py，把你原本 main 裡面跟「初始化」相關的程式（logger, session timeout, 讀 config）搬進來，並讓 create_app() 回傳 app。先不要動 route。

修改 main.py 改成簡單啟動檔，確認 flask run 或 python main.py 能正常啟動（應該與之前行為一致）。

把一個小且自包含的 route（例如 /api/admin/users）複製到 app/routes/admin.py，並在 create_app 註冊 admin blueprint。啟動，測試該 API 是否仍工作。若失敗，回退、修正。

依次遷移其他路由（每次只一個檔案或一小組 route），並在遷移後執行自動測試或手動測試。

把 scheduler 抽出到 app/scheduler（並保留在 production 模式下啟動）。

最終把 main.py 變乾淨（少於 30 行）。

這就是所有的第一階段開發了，完結灑花

第二階段
按摩的部分該怎麼處理?
當訊息發送後，能夠自動確認嗎?如果對方說好，或是沒問題

其他部分
[WARNING] Invalid request from ip=3.131.215.38: Invalid HTTP request line: 'SSH-2.0-Go'

這條日誌的意思是：您的 Gunicorn 網頁伺服器收到了一個來自 IP 位址 3.131.215.38 的請求，但這個請求的格式不正確，它看起來像是一個 SSH 連線請求 (SSH-2.0-Go)，而不是一個標準的 HTTP 請求（例如 GET / 或 POST /api/...）。

這是什麼問題？
這不是您程式的錯誤，而是一個非常普遍的網路現象。簡單來說：

有一個自動化程式（俗稱「機器人」或「掃描器」）試圖用 SSH 協定來連線您正在運作 Gunicorn 的那個連接埠（Port）。

為什麼會發生這種事？
網路掃描：網際網路上有成千上萬的自動化機器人，它們會持續不斷地掃描所有 IP 位址的常用連接埠（例如 80, 443, 22, 5000, 8080 等）。
協定猜測：當掃描器發現您伺服器的某個連接埠是開放的，它不知道這個連接埠後面是什麼服務。於是它會嘗試用各種常見的協定（如 HTTP, HTTPS, SSH, FTP 等）去「打招呼」，看看哪個能成功。
日誌產生：在這個案例中，您的 Gunicorn 伺服器（一個 HTTP 伺服器）收到了來自 SSH 用戶端的「招呼」，Gunicorn 看不懂，於是禮貌地拒絕了它，並記錄下這條警告：「嘿，我收到一個不是 HTTP 的奇怪請求」。
SSH-2.0-Go 這個字串是 Go 語言寫的 SSH 客戶端在建立連線時發送的第一個識別訊息。

這危險嗎？我該怎麼辦？
危險性：這個單一事件本身並不危險。您的 Gunicorn 伺服器正確地處理了這個無效請求，沒有讓它進入您的應用程式內部。
警示意義：這條日誌提醒了您一件事——您的應用程式連接埠直接暴露在公網上，並且正在被掃描。這是所有上線服務的日常。
建議的處理方式
雖然單一事件無害，但最佳實踐是加強伺服器的防護，減少這類「噪音」並提高安全性：

使用防火牆：這是最重要的一步。設定伺服器的防火牆（例如 Linux 上的 ufw），只開放您真正需要的連接埠。

22 (SSH，建議限制特定 IP 才能連線)
80 (HTTP)
443 (HTTPS)
關閉其他所有對外連接埠，包括您 Gunicorn 正在使用的 5000。
使用反向代理 (Reverse Proxy)：這是標準的生產環境部署方式。

讓 Nginx 或 Apache 等網頁伺服器監聽 80 和 443 連接埠，並處理所有來自外部的流量。
然後讓 Nginx/Apache 將合法的 HTTP 請求轉發到您內部運行的 Gunicorn (localhost:5000)。
這樣一來，外部的掃描器只會接觸到 Nginx，而無法直接騷擾您的 Gunicorn 應用程式。